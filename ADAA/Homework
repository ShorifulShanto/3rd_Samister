‎1. Algorithm
‎
‎An algorithm is a step-by-step set of instructions used to solve a problem or perform a task.It's a clear, finite sequence of operations that, when executed, leads to a desired outcome. Think of it as a recipe for computation. 
‎
‎Think of it like a recipe: clear, finite, and repeatable.
‎
‎
‎
‎---
‎
‎2. Why We Use Algorithms
‎
‎--Solve problems efficiently
‎
‎--Reduce time and effort
‎
‎--Ensure solutions are repeatable and reliable
‎
‎--Optimize resource usage in programming
‎
‎
‎
‎---
‎
‎3. Characteristics of a Good Algorithm
‎
‎Clear & Unambiguous – The algorithm should be unambiguous. Each of its steps should be clear in all aspects and must lead to only one meaning.
‎
‎Finite – The algorithm must be finite, i.e. it should terminate after a finite time.
‎
‎Input – If an algorithm says to take inputs, it should be well-defined inputs. It may or may not take input.
‎
‎Output – The algorithm must clearly define what output will be yielded and it should be well-defined as well. It should produce at least 1 output.
‎
‎Effective – An algorithm must be developed by using very basic, simple, and feasible operations so that one can trace it out by using just paper and pencil.
‎
‎Efficient – uses minimal time and memory
‎
‎
‎
‎---
‎
‎4. Types of Algorithms
‎
‎Brute Force – try all possible solutions until the answer is found
‎
‎Greedy – pick the best choice at each step (locally optimal)
‎
‎Divide & Conquer – break the problem into smaller parts, solve them, and combine results
‎
‎Dynamic Programming – solve sub-problems once, store results, and reuse
‎
‎Recursive – function calls itself to solve smaller versions of the problem
‎
‎Backtracking – explore all possibilities but discard paths that don’t work early
‎
‎Search Algorithms – find data in a structure (linear, binary, etc.)
‎
‎Sorting Algorithms – arrange data in a specific order
‎
‎
‎
‎---
‎
‎5. Recursion
‎
‎Recursion is a programming technique where a function calls itself within its own definition to solve a problem by breaking it down into smaller, self-similar subproblems, until it reaches a base case.
‎Example:
‎
‎
‎int factorial(int n) {
‎    if (n == 0) return 1;
‎    return n * factorial(n - 1);
‎}
‎
‎
‎---
‎
‎6. Greedy Algorithm
‎
‎Chooses the best option at each step without worrying about the overall solution.
‎
‎Works well for problems like coin change or activity selection.
‎Example:
‎
‎To give 37 taka using the least coins, pick the largest coin first.
‎
‎
‎
‎---
‎
‎7. Memoization
‎
‎A technique in dynamic programming where we store the results of expensive function calls and reuse them instead of recalculating.
‎Example: Caching Fibonacci results.
‎
‎
‎
‎---
‎
‎8. Searching Algorithms
‎
‎8.1 Linear Search
‎
‎Check each element one by one until the desired item is found.
‎
‎
‎int linearSearch(int arr[], int n, int key) {
‎    for (int i = 0; i < n; i++)
‎        if (arr[i] == key) return i;
‎    return -1;
‎}
‎
‎8.2 Binary Search
‎
‎Searches in a sorted list by repeatedly dividing the search range in half.
‎
‎
‎int binarySearch(int arr[], int n, int key) {
‎    int low = 0, high = n - 1;
‎    while (low <= high) {
‎        int mid = (low + high) / 2;
‎        if (arr[mid] == key) return mid;
‎        else if (arr[mid] < key) low = mid + 1;
‎        else high = mid - 1;
‎    }
‎    return -1;
‎}
‎
‎
‎---
‎
‎9. Abstract Data Type (ADT)
‎
‎A model for data structures where the implementation is hidden; only operations are defined.
‎
‎Example: Stack, Queue, List
‎
‎
‎
‎---
‎
‎10. Time Complexity
‎
‎Measures how the runtime of an algorithm grows with input size (n).
‎
‎
‎
‎---
‎
‎11. Space Complexity
‎
‎Measures how much memory an algorithm uses.
‎
‎
‎
‎---
‎
‎12. Sorting Algorithms
‎
‎Bubble Sort
‎
‎Repeatedly compares adjacent elements and swaps them if they are in the wrong order.
‎
‎
‎void bubbleSort(int arr[], int n) {
‎    for (int i = 0; i < n-1; i++)
‎        for (int j = 0; j < n-i-1; j++)
‎            if (arr[j] > arr[j+1])
‎                swap(&arr[j], &arr[j+1]);
‎}
‎
‎
‎---
‎
‎13. Asymptotic Notations
‎
‎Used to describe the performance of algorithms as input size grows.
‎
‎Big O (O) – Worst Case
‎
‎Example: Linear search → O(n)
‎
‎
‎Theta (Θ) – Average Case
‎
‎Example: Binary search → Θ(log n)
‎
‎
‎Big Omega (Ω) – Best Case
‎
‎Example: Linear search (key at first position) → Ω(1)
‎
‎
‎
‎
‎---
‎
